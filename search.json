[
  {
    "objectID": "posts/FinalProject-Blog.html",
    "href": "posts/FinalProject-Blog.html",
    "title": "DH140 Final Project",
    "section": "",
    "text": "DH140 Final Project\nCreated by Tina Huang\n3/20/2023\n\n\nFor my final project, I will be analyzing the 7 Harry Potter books by J.K. Rowling. The dataset can be found on Github. I wanted to analyze this data because I grew up reading the books and have a renewed interest since the game “Hogwarts Legacy” recently came out. Using data analysis, is there is a significant different in sentiment over the course of each book, as well as compared across all 7 books? Additionally, how do the relationships between the characters change over the 7 books?\n\n\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef readTextFile(fileName):\n    fileString = \"\"\n    \n    with open(fileName, 'r') as f:\n        for line in f:\n            if not line.startswith(\"Page | \") and line.strip():\n                fileString += \" \" + line.strip()\n                \n    return fileString\n\nbook1_str = readTextFile(\"data/Book 1 - The Philosopher's Stone.txt\")\nbook2_str = readTextFile(\"data/Book 2 - The Chamber of Secrets.txt\")\nbook3_str = readTextFile(\"data/Book 3 - The Prisoner of Azkaban.txt\")\nbook4_str = readTextFile(\"data/Book 4 - The Goblet of Fire.txt\")\nbook5_str = readTextFile(\"data/Book 5 - The Order of the Phoenix.txt\")\nbook6_str = readTextFile(\"data/Book 6 - The Half Blood Prince.txt\")\nbook7_str = readTextFile(\"data/Book 7 - The Deathly Hallows.txt\")\n\nbook_dict = {\"The Philosopher's Stone\": book1_str, \n             \"The Chamber of Secrets\": book2_str, \n             \"The Prisoner of Azkaban\": book3_str, \n             \"The Goblet of Fire\": book4_str, \n             \"The Order of the Phoenix\": book5_str, \n             \"The Half Blood Prince\": book6_str, \n             \"The Deathly Hallows\": book7_str}\n\n\n\n\n\n\n\nI am analyzing the evolution of sentiment within the books. First, I want to take a look at the most common positive and negative words within the first book to get a sense of what themes may be present.\nThen, I will analyze the evolution of sentiment by taking sections of 500 words and calculating the average sentiment for each section.\n\nimport nltk\nfrom nltk.tokenize import word_tokenize\nfrom nltk.tokenize import sent_tokenize\nfrom nltk.sentiment import vader\nfrom nltk.corpus import stopwords\nfrom nltk.corpus import opinion_lexicon\nfrom nltk.stem.porter import PorterStemmer\nfrom string import punctuation\n\nnltk.download('punkt')\nnltk.download('stopwords')\nnltk.download('vader_lexicon')\nnltk.download('opinion_lexicon')\n\nsia = vader.SentimentIntensityAnalyzer()\n\n[nltk_data] Downloading package punkt to /home/jovyan/nltk_data...\n[nltk_data]   Package punkt is already up-to-date!\n[nltk_data] Downloading package stopwords to /home/jovyan/nltk_data...\n[nltk_data]   Package stopwords is already up-to-date!\n[nltk_data] Downloading package vader_lexicon to\n[nltk_data]     /home/jovyan/nltk_data...\n[nltk_data]   Package vader_lexicon is already up-to-date!\n[nltk_data] Downloading package opinion_lexicon to\n[nltk_data]     /home/jovyan/nltk_data...\n[nltk_data]   Package opinion_lexicon is already up-to-date!\n\n\n\n# analyzing book 1\npos_words = []\nneg_words = []\n\nfor word in book1_str.split():\n  comp_score = sia.polarity_scores(word)['compound']\n  if comp_score > 0:\n    pos_words.append(word)\n  elif comp_score < 0:\n    neg_words.append(word)\n\n\npos_items = nltk.FreqDist(pos_words).most_common(15)\nx, y = zip(*pos_items)\nx = reversed(x)\ny = reversed(y)\nplt.barh(list(x), list(y))\nplt.xlabel(\"Frequency\")\nplt.ylabel(\"Words\")\nplt.title(\"Most Common Positive words in 'The Philosopher's Stone'\")\n\nText(0.5, 1.0, \"Most Common Positive words in 'The Philosopher's Stone'\")\n\n\n\n\n\n\nneg_items = nltk.FreqDist(neg_words).most_common(15)\nx, y = zip(*neg_items)\nx = reversed(x)\ny = reversed(y)\nplt.barh(list(x), list(y))\nplt.xlabel(\"Frequency\")\nplt.ylabel(\"Words\")\nplt.title(\"Most Common Negative words in 'The Philosopher's Stone'\")\n\nText(0.5, 1.0, \"Most Common Negative words in 'The Philosopher's Stone'\")\n\n\n\n\n\nThrough the previous 2 graphs, we can gather some overall themes of the first book, The Philosopher’s Stone. The most common positive words don’t give much indication of the themes, but the negative words convey a somber tone for the book. The words “kill”, “strange”, “horrible”, “empty”, “forgotten”, and “dead” suggest themes of isolation and pain, which connects to the abuse Harry Potter experiences after his parents died and left him in the care of the abusive Durselys.\n\npositive_words = set(opinion_lexicon.positive())\nnegative_words = set(opinion_lexicon.negative())\n\ndef sentiment_score(word):\n    if word in positive_words:\n        return 1\n    elif word in negative_words:\n        return -1\n    else:\n        return 0\n\ndef total_sentiment_score(book_string):\n    words = []\n    sent = sent_tokenize(book_string)\n\n    for s in sent:\n        for w in word_tokenize(s):\n            words.append(w)\n    \n    # calculate score for each block of 500 words\n    scores = []\n    i = 0\n    x = 0\n    \n    while i < len(words) - 500:\n      score = 0\n      for j in range(500):\n        score += sentiment_score(words[x])\n        x += 1\n      scores.append(score)\n      i += 500\n        \n    return scores\n\n\nbook1_scores = total_sentiment_score(book1_str)\nbook2_scores = total_sentiment_score(book2_str)\nbook3_scores = total_sentiment_score(book3_str)\nbook4_scores = total_sentiment_score(book4_str)\nbook5_scores = total_sentiment_score(book5_str)\nbook6_scores = total_sentiment_score(book6_str)\nbook7_scores = total_sentiment_score(book7_str)\n\nOriginally, I wished to plot all 7 books’ sentiment scores on the same graph, but I realized quickly that it would become way too messy and difficult to read. Therefore, I selected books in groups of 2 based on similar word count lengths and chronological order.\n\n# books 1 and 2\nfig, ax = plt.subplots()\nl1, = ax.plot(range(len(book1_scores)), book1_scores)\nl2, = ax.plot(range(len(book2_scores)), book2_scores)\nax.set_xlabel(\"Group Number\")\nax.set_ylabel(\"Sentiment score\")\nax.set_title(\"First 2 Harry Potter Sentiment Scores\")\nax.legend((l1, l2), ('Book 1', 'Book 2'), loc='upper right')\n\n<matplotlib.legend.Legend at 0x7f9d3a021480>\n\n\n\n\n\nI first selected books 1 and 2 to compare together since they have similar word count lengths. This graph shows that the change in sentiment over time is pretty similar for books 1 and 2. Both books reach a low negative sentiment towards the end of the book, but then increase to a positive sentiment at the very end. The major differences are that in book 2, there is a big decrease in sentiment around group 50, which is roughly in the first 1/4 or 1/5 of the book.\n\n# books 2 and 3\nfig, ax = plt.subplots()\nl2, = ax.plot(range(len(book2_scores)), book2_scores)\nl3, = ax.plot(range(len(book3_scores)), book3_scores)\nax.set_xlabel(\"Group Number\")\nax.set_ylabel(\"Sentiment score\")\nax.set_title(\"Harry Potter Books 2 and 3 Sentiment Scores\")\nax.legend((l2, l3), ('Book 2', 'Book 3'), loc='upper right')\n\n<matplotlib.legend.Legend at 0x7f9d3958c790>\n\n\n\n\n\nI then compared the sentiment scores of books 2 and 3 because they also had similar word counts. Though book 3’s length is greater than book 2, the sentiment scores up to the end of book 2 follow a very similar trend. Around group number 50, both books have a sharp decrease in sentiment score. Around group 225, there is another sharp decrease in sentiment score. This implies that these books follow a similar narrative structure.\nBook 2 has a much more maximum negative sentiment value of around -20, whereas its maximum positive sentiment value is around 14. This shows that book 2 may discuss more overall negative themes. Book 3 has an overall more negative sentiment score for the majority of the book, but then increases from -20 to 15 during the last portion of the book.\n\n# books 4 and 7\nfig, ax = plt.subplots()\nl4, = ax.plot(range(len(book4_scores)), book4_scores)\nl7, = ax.plot(range(len(book7_scores)), book7_scores)\nax.set_xlabel(\"Group Number\")\nax.set_ylabel(\"Sentiment score\")\nax.set_title(\"Harry Potter Books 4 and 7 Sentiment Scores\")\nax.legend((l4, l7), ('Book 4', 'Book 7'), loc='upper right')\n\n<matplotlib.legend.Legend at 0x7f9d39fe6f50>\n\n\n\n\n\nI analyzed books 4 and 7 because they have very similar word count lengths. These books are a little more different than the previous graphs, possibly due to the greater gap in time between when the books were written and published. Book 7 has an overall more negative sentiment, with a huge decrease in sentiment around group 225. Book 4 averages around a sentiment score of 0, but starts becoming slightly more negative towards the end of the book.\n\n\n\nI created network graphs of the characters’ relationships by counting the frequencies of interactions between characters. The frequency of interactions was counted by seeing if 2 characters’ names occured one after another. Then, I created a network graph with these character interactions.\nSomething that was challenging was figuring out when characters interacted with each other; unlike a play where the script says the full name of the character that’s speaking, a novel may refer to people by their first name, last name, both first and last name, or by a nickname. Additionally, their name may not be specified each time during the dialogue; pronouns may be used where the reader has to use reading comprehension to figure out who the pronoun is referring to. Additionally, many characters are related and have the same last name, so readers have to use reading comprehension to know which character is being referred to.\nTo simplify things, I modified the character list to include only the most common names each character is referred to as. I determined this by mostly using people’s first names, or using my knowledge of the books plus the help of the internet. For example, the name “Mr. Potter” is ambiguous because we don’t know which Potter that is. So, I only include “Harry”, “Albus”, and “James” since these are unique first names to differentiate the Potter men.\n\nimport networkx as nx\nfrom bokeh.io import output_notebook, show, save\nfrom bokeh.models import Range1d, Circle, ColumnDataSource, MultiLine, EdgesAndLinkedNodes, NodesAndLinkedEdges, LabelSet\nfrom bokeh.plotting import figure\nfrom bokeh.plotting import from_networkx\nfrom bokeh.palettes import Blues8, Reds8, Purples8, Oranges8, Viridis8, Spectral8\nfrom bokeh.transform import linear_cmap\nfrom networkx.algorithms import community\n\n\nchar_names = [ \"Harry\", \"Hermione\", \"Ron\", \"Dumbledore\", \"Luna\", \"Dobby\", \"Hagrid\", \"Lupin\", \"Neville\", \"Lilly\", \"Tonks\", \n             \"James\", \"Fleur\", \"Crabbe\", \"Malfoy\", \"Albus\", \"Narcissa\", \"George\", \"Percy\", \"Molly\", \"Dudley\",\n             \"Slughorn\", \"Lily\", \"Fitwick\", \"Petunia\", \"Helena\", \"Vernon\", \"Lockhart\", \"Viktor\", \"Patil\", \"Ted\", \"Noris\" ]\n\n# return a dictionary that maps the frequency of characters' interactions\n# represents a bidirectional relationship between character names to the frequency of their interactions\ndef find_char_relations(book_string):\n  char_dict = {}\n  prev_char = \"Harry\"\n  words = []\n  sent = sent_tokenize(book_string)\n\n  for s in sent:\n      for w in word_tokenize(s):\n          words.append(w)\n            \n  for word in words:\n    if word in char_names and word != prev_char:\n      if (prev_char, word) in char_dict:\n        char_dict[(prev_char, word)] += 1\n      elif (word, prev_char) in char_dict:\n        char_dict[(word, prev_char)] += 1\n      else:\n        char_dict[(prev_char, word)] = 1\n      prev_char = word\n\n  return char_dict\n\ndef plot_char_relations(book_str, bookNum):\n  book_chars = find_char_relations(book_str)\n\n  # convert to a dataframe\n  tuples = book_chars.keys()\n  df = pd.DataFrame({'Source': [tuple[0] for tuple in tuples],\n                     'Target': [tuple[1] for tuple in tuples],\n                     'Weight': book_chars.values()})\n  book_chars = {v:k for k,v in dict(pd.Series(list(set(df.Target.unique()).union(set(df.Source.unique())))).astype(\"category\")).items()}\n  book_charindex_dict = {v:k for k,v in book_chars.items()}\n  df['SourceIndex'] = [book_chars[i] for i in df['Source'].values]\n  df['TargetIndex'] = [book_chars[i] for i in df['Target'].values]\n\n  G = nx.from_pandas_edgelist(df, 'SourceIndex', 'TargetIndex', 'Weight')\n  nx.set_node_attributes(G, name='charname', values=book_charindex_dict)\n\n  #Choose colors for node and edge highlighting\n  node_highlight_color = 'white'\n  edge_highlight_color = 'black'\n\n  #Choose attributes from G network to size and color by — setting manual size (e.g. 10) or color (e.g. 'skyblue') also allowed\n  size_by_this_attribute = 'adjusted_node_size'\n  color_by_this_attribute = 'modularity_color'\n\n  #Pick a color palette — Blues8, Reds8, Purples8, Oranges8, Viridis8\n  color_palette = Blues8\n\n  #Choose a title!\n  title = 'Harry Potter Book ' + str(bookNum) + ' Network' \n\n  #Establish which categories will appear when hovering over each node\n  HOVER_TOOLTIPS = [\n      (\"Character\", \"@index\"),\n      (\"Degree\", \"@degree\"),\n      (\"Modularity Class\", \"@modularity_class\"),\n      (\"Modularity Color\", \"$color[swatch]:modularity_color\"),\n  ]\n\n  #Create a plot — set dimensions, toolbar, and title\n  plot = figure(tooltips = HOVER_TOOLTIPS,\n                tools=\"pan,wheel_zoom,save,reset\", active_scroll='wheel_zoom',\n                x_range=Range1d(-10.1, 10.1), y_range=Range1d(-10.1, 10.1), title=title)\n\n  #Create a network graph object\n  # https://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.drawing.layout.spring_layout.html\n  network_graph = from_networkx(G, nx.spring_layout, scale=10, center=(0, 0))\n\n  #Set node sizes and colors according to node degree (color as category from attribute)\n  network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)\n  #Set node highlight colors\n  network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)\n  network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)\n\n  #Set edge opacity and width\n  network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)\n  #Set edge highlight colors\n  network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)\n  network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)\n\n  #Highlight nodes and edges\n  network_graph.selection_policy = NodesAndLinkedEdges()\n  network_graph.inspection_policy = NodesAndLinkedEdges()\n\n  plot.renderers.append(network_graph)\n\n  #Add Labels\n  x, y = zip(*network_graph.layout_provider.graph_layout.values())\n  node_labels = list(G.nodes())\n  source = ColumnDataSource({'x': x, 'y': y, 'name': [book_charindex_dict[i] for i in node_labels]})\n  labels = LabelSet(x='x', y='y', text='name', source=source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.7)\n  plot.renderers.append(labels)\n\n  output_notebook()\n  show(plot)\n  save(plot, filename=f\"{title}.html\")\n\n\nplot_char_relations(book1_str, 1)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book2_str, 2)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book3_str, 3)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book4_str, 4)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book5_str, 5)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book6_str, 6)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\n\nplot_char_relations(book7_str, 7)\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n  \n\n\n\n\n\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no resources were supplied and output_file(...) was never called, defaulting to resources.CDN\n  save(plot, filename=f\"{title}.html\")\n/tmp/ipykernel_284/446730918.py:103: UserWarning: save() called but no title was supplied and output_file(...) was never called, using default title 'Bokeh Plot'\n  save(plot, filename=f\"{title}.html\")\n\n\nIn the network graph for book 1, we can see that Harry Potter is at the center of the graph with many connections with other characters. This is unsurprising, since he is the main character. We also see through connections between Harry Potter and Dumbledore, Hagrid, Hermione, Vernon, Lily, and Dudley. Knowing the plot of the first book, we know that this makes sense because Harry has many interactions with Dudley and Vernon Dursley at the beginning of the book as we begin to understand his origins. Then, he gets whisked away to Hogwarts by Hagrid and meets characters like Dumbledore, Malfoy, Hermione, and Ron. We can see a slight separation in the graph between Harry’s Hogwarts connections and his Muggles relationships.\nA comparison between the network graphs for book 1 and 7 demonstrates how the relationships become much more intricate and complex. This makes sense because the plot has greatly developed over the course of 7 books and we are introduced to many more characters. Harry Potter is still at the center of the graph, but there is no longer a separation between groups in the relationships. This is because Harry Potter becomes immersed in the wizarding world, and thus has many more interactions between other wizards. His closest friends, Hermione and Ron, are still very close connections to him, as well as Dumbledore and Hagrid.\n\n\n\n\nUsing sentiment analysis and network graph analysis allows us to see interesting similarities and differences across the 7 Harry Potter books.\n\n\nPerforming the sentiment analysis with pairs of books with similar word counts demonstrates how most of the books follow a pretty similar structure. This suggests there may be a pattern for how the tone of the books rise and fall; for example, books 1 and 2 changes sentiment up and down over the course of each book, but both end with a drastic drop in sentiment and then a rise in positive sentiment.\nBecause sentiment analysis generally corresponds to the rising and falling of the plot, we can hypothesize that these changes in sentiment may have contributed to a successful formula that led to the popularity of these books. Perhaps readers enjoy books with lots of twist and turns instead of ones with a flat sentiment over the entire course of the book. Maybe for a series of books, it is good to have a hopeful ending at the end of each book after the characters go through a challenging experience with negative emotions.\nLooking at this sentiment analysis can be useful to not only understand more deeply about the Harry Potter series, but can also be compared against other book series to find similarities and differences. I would be curious to see how other popular book series compare in their sentiment analysis and if they follow a similar evolution in sentiment. If so, that may form a hypothesis on what plotlines may correlate with book popularity and success.\n\n\n\nThe network graph analysis is very interesting to show the changes over the course of the Harry Potter series. As expected, we see how the main character Harry Potter’s relationships grow increasingly complex as we are introduced to more and more characters.\nNetwork graph analysis is useful to better understand the dynamics of the relationships. We may also spot things we may not have noticed before without a graph; for example, in the first book, we see how Harry Potter’s relationships are grouped by Muggles and Wizards, something that may not be immediately clear when just looking at raw data. We can also see recurring characters who always remain in Harry Potter’s close circle, such as Hermione, Ron, and Dumbledore. From this network graph, we can also glean which characters are the most important in Harry Potter’s life, as counted by their number of interactions together.\nGenerally speaking, network graphs are very useful for people to easily understand data, particularly for character relationships. Simply looking at numbers, like the number of interactions between characters, is extremely hard to understand. In a graph format, we can also see subgroups that may represent different relationship worlds within the text. With an even more in depth graph, it may also be possible to label the vertices with the type of relationship between characters, which may further increase people’s understanding of overall relationships. Especially for text that may have a lot of characters, these graphs can be useful for people to reference so they know who is who.\nOverall, we can use these analyses to better understand the Harry Potter books. We can try to see patterns of the plotlines, as well as map out the character relationships. This can lead to a deeper understanding and enjoyment of the books beyond the words within the text."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TinaBlog",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 11, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDH140 Final Project\n\n\n\n\n\nHarry Potter Books\n\n\n\n\n\n\nMar 10, 2023\n\n\nTina Huang\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 8, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]